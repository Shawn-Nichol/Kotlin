Classes in Kotlin are declared using the keyword 'class'
```
class MyClass {
  //.....
}
```
The class declaration consists of the class name, the class header(primary constructor), and the class body, surrounded by curly braces. Both header and the body are optional;
if the class has no body, the curly braces can be omitted. 

```
class Empty
```

Constructors
 A class in kotlin can have a primary constructor and one or more secondary constructors. The primary constructor is part of the class header: it goes after the classname
 and optional type parameters
 ```
 class Person constructor(firstName: String) {
 
 }
 ```
 
 If the primary constructor does have any annotations or visiblity modifiers, the 'constructor' keyword can be omitted. The primiary constructor can not contain any code, 
 initialization code can be entered in the 'init' block. During an instance initialization the initializer blcks are executed in the same order as they appear in the class body,
 interleaveed with the property initializers.
 
 ```
 class MyClass(name: String) {
  val firstProperty = "First property: $name".also(::println)
  init {
    println("First initializer block that prints ${name}")
  }
  val secondProperty = "Second property: ${name.length}")
  init {
    println("Second initializer: ${name.length}")
  }
}
```
The parameters of the primary constructor can be used in the 'init' block. In fact for declaring properties and intializing them from the primary constructor, kotlin has concise
syntax:
```
class Person(val firstName: String, val lastName: String, var age: Int) {
}
```

If the construtor has annotations or visibility modifiers, the constructor keyword is required, and the modifiers go before it. 
```
class Customer public @Inject constructor(name: String) {

}
```


Secondary Constructors
The class can also declare secondary constructgors, which are prefixed with constructor
```
class Person {
  var children: Mutablist<Person> = mutableListOf<>()
  constructore(paretn: Person) {
    parent.children.add(this)
  }
}
```

If the class has a primary constructor, each scondary constructor needs to delegate to the primary constructor, eitehr 
directly or indirectly through another seocndray construcor. Delegation to another constructor of the same class is odne using
the 'this' keyword
```
class Person(val name: String) {
  var childre: MutableList<Person> = mutableListof<>()
  constructor(name: String, parent: Person) : this(name) {
    parent.children.add(this)
  }
}
```

Note code in the initializer blocks effectively becomes part of the primary constructor. Delegation to the primary constructor happens 
as the first staement of a scondary constructor, so the code in all initializer blocks and proeprty initializers is executed before the
secondary constructor body.  Even if the calls has no primary constructor, the delegatioin stil happens implicityly, and the intializer 
blocks are still executed:
```
class Constructors {
  int {
    println("Init block")
  }
  
  constructor(i: Int) {
    println("Constructor")
  }
}
```

If a non-abstract class does not declare any constructors, it will have a generated primary constructor with no arguments. The visibility of the constructor will be public.
If you do not want your class to have a public oconstructor, you need to dceclare an empty primary constructor with non-deafult visibility. 
```
class DontCreateMe private constructor() { /******/}
```

Create Instances of classes
To create an instance of a class, we call the constructor as if it were a regular function:
```
val invoice = Invoice()
val customer = Customer("Joe Smith")
```


Class members
Class members can contain the following
- Constructors and initializer blocks
- Functions
- Properties
- Nested and inner classe
- Object Declarations

Inheritance
All classes in kotlin have a common superclass Any, that is the default supercalsss for a class with no sypertypes declared. 
```
call Example // Implicityly inherits from Any
```

Any has three methods equals(), hashCode() and to String(). Thus they are dfined for all kotlin classes.

By default kotlin classess are final: they can't be inherited. To make a class inheritable, mark it with the open keyword. 
```
open class Base // Class is open for inheritance
```
To delcare an explicit supertype, place the type after a colon in the class header:
```
open class Base(p: Int)
class Derived(p: Int) : Base(p)
```

If the derived class has a primary constructor, the base class can be initialized right there, using teh parameters of the primary constructor. 

If the derived class has no primary constructor, then each secondary constructor has to initialize the base type using the super kyword, or to 
delegate to another constructor which does that. Note that in this case different secondary constructors can call different secondary constructors
can call different constructors of the base type:
```
Class MyView :View {
  constructor(ctx: Context) : super(ctx)
  constructor ctx: Context, attrs: AttributeSet) : super(ctx, attrs)
}
```


Overriding methdos 
Kotlin requires explicit modifiers for overridable members and for overrides:
```
open class Shape {
  open fun draw()( {/****/}
  fun fill() {/*******/}
}

class Circle() : Shape() {
  override fun draw() {/*****/}
}
```

The override modifier is required for Circle.draw(). If it were missing, teh compiler would complain. If there is no open modifier on a function, like shape.fill(), 
declaring a method with the same signature in a subclass is illegal, either with override or without it. The open modifier has no effect when added on memebers of a final class

A member marked override is itself open, i.e. it may be overridden in subclasses. If you want to prohit re-overriding , use final
```
open class Rectangle() : Shape()
  final override fun draw() {/*****/}
```


Overriding properties
Overridign proeprties works in a simliar way to overriding methods; properties declared on a superclass that are then redclared on a derived class must be prefaced with Override, 
and they must have a compatible type. Each declared property  can be overridden by a propety with an initializer or by a property with a get method. 
```
open class Shape {
  open val vertextCount: Int = 0
}

class Rectangle : Shape() {
  override val vertexCount = 4
}
```
You can also override a val property with a var property, but not vice versa. Thjis allowed becuase a val property essentially declares a get methdo, and overriding it as a var 
additionally declars a set method in the derived class. 

Note that you can use teh override keywordd as part of the proerty declaration in a primary constructor. 
interface Shape {
  val vertexCount: int
}

class Rectangle (overide val vertexCount: int = 4) : Shape // alwayus has 4 vertices

class Polygon : Shape {
  override var vertextCount: Int = 0 // can be set to any number later
}
```


